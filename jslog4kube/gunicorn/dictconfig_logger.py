# pylint: disable=invalid-name
'''

This is copied directly from `gunicorn.glogging.Logger` class.

    * `format_str` reflects the string generated by jslog4kube
    * the logging system is initialized with the configuration dict
      defined in `jslog4kube.kube.log_config` rather than with
      the default fileConfig mechanism


'''

import logging
from logging.config import dictConfig
import os
import sys
from gunicorn import util
from gunicorn.glogging import Logger, CONFIG_DEFAULTS
from ..kube.log_config import LOGGING
from .. import format_str


class GunicornLogger(Logger):
    '''
    overrides gunicorn's Logger class to provide dictionary configuration
    capabilities
    '''
    error_fmt = format_str
    access_fmt = format_str

    def setup(self, cfg):
        self.loglevel = self.LOG_LEVELS.get(cfg.loglevel.lower(), logging.INFO)
        self.error_log.setLevel(self.loglevel)
        self.access_log.setLevel(logging.INFO)

        # set gunicorn.error handler
        if self.cfg.capture_output and cfg.errorlog != "-":
            for stream in sys.stdout, sys.stderr:
                stream.flush()

            self.logfile = open(cfg.errorlog, 'a+')
            os.dup2(self.logfile.fileno(), sys.stdout.fileno())
            os.dup2(self.logfile.fileno(), sys.stderr.fileno())

        self._set_handler(self.error_log, cfg.errorlog,
                          logging.Formatter(self.error_fmt, self.datefmt))

        # set gunicorn.access handler
        if cfg.accesslog is not None:
            self._set_handler(self.access_log, cfg.accesslog,
                fmt=logging.Formatter(self.access_fmt), stream=sys.stdout)

        # set syslog handler
        if cfg.syslog:
            self._set_syslog_handler(
                self.error_log, cfg, self.syslog_fmt, "error"
            )
            if not cfg.disable_redirect_access_to_syslog:
                self._set_syslog_handler(
                    self.access_log, cfg, self.syslog_fmt, "access"
                )

        if dictConfig is None and cfg.logconfig_dict:
            util.warn("Dictionary-based log configuration requires "
                      "Python 2.7 or above.")

        if dictConfig and cfg.logconfig_dict:
            config = CONFIG_DEFAULTS.copy()
            config.update(cfg.logconfig_dict)
            try:
                dictConfig(LOGGING)
            except (
                    AttributeError,
                    ImportError,
                    ValueError,
                    TypeError
            ) as exc:
                raise RuntimeError(str(exc))
        elif cfg.logconfig:
            if os.path.exists(cfg.logconfig):
                defaults = CONFIG_DEFAULTS.copy()
                defaults['__file__'] = cfg.logconfig
                defaults['here'] = os.path.dirname(cfg.logconfig)
                fileConfig(cfg.logconfig, defaults=defaults,
                           disable_existing_loggers=False)
            else:
                msg = "Error: log config '%s' not found"
                raise RuntimeError(msg % cfg.logconfig)

        dictConfig(LOGGING)
